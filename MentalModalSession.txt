 A.How do type guards work? Give examples using typeof, in and user-defined type guard functions.
------------------------------------------------------------------------------------------------
-A type guard is a way to narrow down the type of a variable inside a condition,
 so TypeScript knows exactly what you're working with.
Think of it as: â€œHey TypeScript, I just proved what this thing really is â€” now let me use it properly.â€

-2. Using in â€” for object properties
Use this when you have different objects that share some props and differ in others.

type Admin = { role: "admin"; dashboard: string };
type User = { role: "user"; cart: string[] };

function handlePerson(person: Admin | User) {
  if ("dashboard" in person) {
    console.log("Welcome Admin:", person.dashboard);
  } else {
    console.log("User Cart:", person.cart);
  }
}

3.ğŸ§™ 3. User-defined Type Guards â€” your own ğŸ”¥ logic
You can write your own function that returns a special type:

type Dog = { bark(): void };
type Cat = { meow(): void };

function isDog(animal: Dog | Cat): animal is Dog {
  return "bark" in animal;
}

function makeSound(pet: Dog | Cat) {
  if (isDog(pet)) {
    pet.bark(); // TS knows it's a Dog âœ…
  } else {
    pet.meow(); // TS knows it's a Cat âœ…
  }
}




| Guard Type | Syntax/Keyword            | Use Case                                       |
| ---------- | ------------------------- | ---------------------------------------------- |
| `typeof`   | `typeof value === "type"` | Use with primitives (`string`, `number`, etc.) |
| `in`       | `"prop" in object`        | Use to check if a prop exists in an object     |
| **Custom** | `function x is Y()`       | Write your own logic for complex types         |

B.What are conditional types (e.g. T extends U ? X : Y)? Provide a real-world use case.
//used inside generics


C.
Whatâ€™s the difference between interface and type aliases? When would you choose one over the other?
- Both interface and type are used to describe the shape of data (aka: objects, functions, etc.)
 But they got some differences â€” letâ€™s unpack them like this:
-interface uses extend while types uses intersection 

*Declaration Merging â€“ Only interfaces can do this!  
interface Book {
  title: string;
}

interface Book {
  author: string;
}

// âœ… This merges into:
interface Book {
  title: string;
  author: string;
}
..only interface can do these 


*4. Functions, Primitives, and Unions â€“ Only type can do this!

type ID = string | number; // âœ… Union type
type Status = "active" | "inactive"; // âœ… Literal types

type Callback = (a: number, b: number) => number; // âœ… Function type

| Situation                                                | Use `interface` if...                | Use `type` if...                    |
| -------------------------------------------------------- | ------------------------------------ | ----------------------------------- |
| You're modeling **objects or classes**                   | âœ… Easier to extend, merge, and scale | ğŸ‘Œ Still works, but less extendable |
| You need **primitive**, **union**, or **function** types | âŒ Not supported                      | âœ… Type handles it perfectly         |
| You want to **merge** declarations                       | âœ… Only `interface` can do this       | âŒ `type` will throw an error        |
| You work in a **class-based or OOP setup**               | âœ… Matches well with `implements`     | ğŸ‘Œ Possible, but less idiomatic     |
| You want **maximum flexibility**                         | ğŸ‘Œ Good                              | âœ… Best for advanced type combos     |
